package com.base;
import java.util.*;
import java.util.Map;
import java.util.HashMap;

public class Text1 extends Text{


        //只能在子类构造调用父类构造 子类继承父类，默认子类有这个这个super()（去调用了父类的构造）;
        //super关键字的三种用法
        //1.通过子类方法访问父类的属性
        //2.通过子类方法访问父类的方法
        //3.通过子类构造访问父类的构造//在第一行
        //super()是调用父类，this()是调用子类，三种关键字的用法差不多
        //多态（Multi）
        //父类的对象指向子类的空间
        //1 成员变量的调用，编译看左边（看左边有没有），运行还看左边（没有则想上找）
        //2 方法的调用，编译看左边（看左边有没有），运行看右边，看new的是谁，没有则想上找。
        //向上转型
        //1就是多态（是安全的），父类的对象指向子类的空间（相当于基本数据类型转换）
        //向下转型
        //将原来的new得空间变为原来的
        //fu 1=new zi();向上转型
        //zi 2=(zi) 1;向下转型（不知道向下转型为谁，要用instanceof 关键字判断）
        //zi2 3=(zi2) 1错误的向下转型（编译不报错，运行异常）
        //instanceof 关键字
        //if(1 instanceof zi){判断是不是可以进行向下转型 （返回值是Boolean）
        //zi 4=(zi) 1;
        //在某些方法传对象参数时判断是new的那个，好物尽其用
        //}
        //final关键字
        //1修饰一个类，当前这个类不能有任何子类，有父类，他的所有方法不能被重写，因为没有子类
        //2修饰一个方法，这个方法不能被重写
        //注意：abstract 和final不能同时用
        //3 修饰一个局部变量，保证有唯一一次复制即可（开始可以不赋值，后来可以有一次赋值）
        //修饰引用类型引用类型地址不能变，但内容可以变。
        //4修饰一个成员变量，由于会有默认值，所以要直接赋值或者构造赋值(所有的构造都会赋值，不管有参无参)
        //权限修饰符
        //public> protected >（default)(就是默认不写) > private
        /* 同一个类    yes     yes           yes                     yes
           同一个包     yes       yes         yes                      no
           不同的包子类   y          y         n                     n
           不同的包非子类  y          n          n                     n
         外部类(public default)
         内部类
         1成员内部类（public protected default private）
         注意：内用外随意访问，外用内要有内部对象。内部可以用外部的私有
         内部类对象的直接定义：外部类名称.内部类名称 对象名= new 外部类名称().new 内部类名称();
         注意：内部类外部类重名时，使用外部类的属性时 外部类名称.this.变量名；
         2 局部内部类(什么都不能写)
         定义在方法里面的类。
         注意：局部内部类访问该方法里面的局部变量，该局部变量不能被改变值，不写final也行，但不能有更改值的语句
         3匿名内部类
         demo3是接口（可以省去定义接口所要实现的类，直接匿名内部类实现接口定义的方法,然后调用）
           demo3 demo=new demo3() {
            @Override
            public void interfaces() {

            }
            };
            demo.interfaces();
            注意:匿名内部类只能在创建对象的时候使用一次，想要再次使用该相同的功能，就得在new
            类，接口也可以作为成员

         */
        //Scanner
    }
